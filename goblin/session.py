"""Main OGM API classes and constructors"""
import asyncio
import collections
import logging
import weakref

from goblin import exception, mapper, traversal
from goblin.driver import connection, graph
from goblin.element import GenericVertex


logger = logging.getLogger(__name__)


class Session(connection.AbstractConnection):
    """Provides the main API for interacting with the database. Does not
       necessarily correpsond to a database session."""

    def __init__(self, app, conn, *, use_session=False):
        self._app = app
        self._conn = conn
        self._loop = self._app._loop
        self._use_session = False
        self._pending = collections.deque()
        self._current = weakref.WeakValueDictionary()
        remote_graph = graph.AsyncRemoteGraph(
            self._app.translator, self,
            graph_traversal=traversal.GoblinTraversal)
        self._traversal_factory = traversal.TraversalFactory(remote_graph)

    @property
    def app(self):
        return self._app

    @property
    def conn(self):
        return self._conn

    @property
    def traversal_factory(self):
        return self._traversal_factory

    @property
    def current(self):
        return self._current

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc, tb):
        await self.close()

    async def close(self):
        await self.conn.close()
        self._app = None

    # Traversal API
    @property
    def g(self):
        """Returns a simple traversal source"""
        return self.traversal_factory.traversal()

    def traversal(self, element_class):
        """Returns a traversal spawned from an element class"""
        return self.traversal_factory.traversal(element_class=element_class)

    async def submit(self,
                    gremlin,
                    *,
                    bindings=None,
                    lang='gremlin-groovy'):
        """Get all results generated by query"""
        await self.flush()
        async_iter = await self.conn.submit(
            gremlin, bindings=bindings, lang=lang)
        response_queue = asyncio.Queue(loop=self._loop)
        self._loop.create_task(
            self._receive(async_iter, response_queue))
        return traversal.TraversalResponse(response_queue)

    async def _receive(self, async_iter, response_queue):
        async for result in async_iter:
            current = self.current.get(result['id'], None)
            if not current:
                element_type = result['type']
                label = result['label']
                if element_type == 'vertex':
                    current = self.app.vertices[label]()
                else:
                    current = self.app.edges[label]()
                    current.source = GenericVertex()
                    current.target = GenericVertex()
            element = current.__mapping__.mapper_func(result, current)
            response_queue.put_nowait(element)
        response_queue.put_nowait(None)

    # Creation API
    def add(self, *elements):
        for elem in elements:
            self._pending.append(elem)

    async def flush(self):
        while self._pending:
            elem = self._pending.popleft()
            await self.save(elem)

    async def remove_vertex(self, element):
        traversal = self.traversal_factory.remove_vertex(element)
        result = await self._simple_traversal(traversal, element)
        element = self.current.pop(element.id)
        del element
        return result

    async def remove_edge(self, element):
        traversal = self.traversal_factory.remove_edge(element)
        result = await self._simple_traversal(traversal, element)
        element = self.current.pop(element.id)
        del element
        return result

    async def save(self, element):
        if element.__type__ == 'vertex':
            result = await self.save_vertex(element)
        elif element.__type__ == 'edge':
            result = await self.save_edge(element)
        else:
            raise exception.ElementError(
                "Unknown element type: {}".format(element.__type__))
        return result

    async def save_vertex(self, element):
        result = await self._save_element(
            element, self._check_vertex,
            self.traversal_factory.add_vertex,
            self.update_vertex)
        self.current[result.id] = result
        return result

    async def save_edge(self, element):
        if not (hasattr(element, 'source') and hasattr(element, 'target')):
            raise exception.ElementError(
                "Edges require both source/target vertices")
        result = await self._save_element(
            element, self._check_edge,
            self.traversal_factory.add_edge,
            self.update_edge)
        self.current[result.id] = result
        return result

    async def get_vertex(self, element):
        return await self.traversal_factory.get_vertex_by_id(
            element).one_or_none()

    async def get_edge(self, element):
        return await self.traversal_factory.get_edge_by_id(
            element).one_or_none()

    async def update_vertex(self, element):
        props = mapper.map_props_to_db(element, element.__mapping__)
        traversal = self.g.V(element.id)
        return await self._update_properties(element, traversal, props)

    async def update_edge(self, element):
        props = mapper.map_props_to_db(element, element.__mapping__)
        traversal = self.g.E(element.id)
        return await self._update_properties(element, traversal, props)

    # Transaction support
    def tx(self):
        raise NotImplementedError

    def _wrap_in_tx(self):
        raise NotImplementedError

    async def commit(self):
        await self.flush()
        if self.engine._features['transactions'] and self._use_session():
            await self.tx()
        raise NotImplementedError

    async def rollback(self):
        raise NotImplementedError

    # *metodos especiales privados for creation API
    async def _simple_traversal(self, traversal, element):
        stream = await self.conn.submit(
            repr(traversal), bindings=traversal.bindings)
        msg = await stream.fetch_data()
        if msg:
            msg = element.__mapping__.mapper_func(msg, element)
            return msg

    async def _save_element(self,
                            element,
                            check_func,
                            create_func,
                            update_func):
        if hasattr(element, 'id'):
            result = await check_func(element)
            if not result:
                traversal = create_func(element)
            else:
                traversal = await update_func(element)
        else:
            traversal = create_func(element)
        return await self._simple_traversal(traversal, element)

    async def _check_vertex(self, element):
        """Used to check for existence, does not update session element"""
        traversal = self.g.V(element.id)
        stream = await self.conn.submit(repr(traversal))
        return await stream.fetch_data()

    async def _check_edge(self, element):
        """Used to check for existence, does not update session element"""
        traversal = self.g.E(element.id)
        stream = await self.conn.submit(repr(traversal))
        return await stream.fetch_data()

    async def _update_properties(self, element, traversal, props):
        binding = 0
        for k, v in props:
            if v:
                traversal = traversal.property(
                    ('k' + str(binding), k),
                    ('v' + str(binding), v))
            else:
                if element.__type__ == 'vertex':
                    traversal_source = self.g.V(element.id)
                else:
                    traversal_source = self.g.E(element.id)
                await traversal_source.properties(
                    ('k' + str(binding), k)).drop().one_or_none()
            binding += 1
        return traversal
