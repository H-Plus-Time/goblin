"""Main OGM API classes and constructors"""
import asyncio
import collections
import logging

from goblin import mapper
from goblin import traversal
from goblin.driver import connection, graph


logger = logging.getLogger(__name__)


class Session(connection.AbstractConnection):
    """Provides the main API for interacting with the database. Does not
       necessarily correpsond to a database session."""

    def __init__(self, app, conn, *, use_session=False):
        self._app = app
        self._conn = conn
        self._loop = self._app._loop
        self._use_session = False
        self._pending = collections.deque()
        self._current = {}
        remote_graph = graph.AsyncRemoteGraph(
            self._app.translator, self,
            graph_traversal=traversal.GoblinTraversal)
        self._traversal_factory = traversal.TraversalFactory(remote_graph)

    @property
    def app(self):
        return self._app

    @property
    def conn(self):
        return self._conn

    @property
    def traversal_factory(self):
        return self._traversal_factory

    @property
    def current(self):
        return self._current

    async def __aenter__(self):
        return self

    async def __aexit__(self):
        await self.close()

    async def close(self):
        await self.conn.close()
        self._app = None

    # Traversal API
    @property
    def g(self):
        """Returns a simple traversal source"""
        return self.traversal_factory.traversal()

    def traversal(self, element_class):
        """Returns a traversal spawned from an element class"""
        return self.traversal_factory.traversal(element_class=element_class)

    async def submit(self,
                    gremlin,
                    *,
                    bindings=None,
                    lang='gremlin-groovy'):
        """Get all results generated by query"""
        await self.flush()
        async_iter = await self.conn.submit(
            gremlin, bindings=bindings, lang=lang)
        response_queue = asyncio.Queue(loop=self._loop)
        self._loop.create_task(
            self._receive(async_iter, response_queue))
        return traversal.TraversalResponse(response_queue)

    async def _receive(self, async_iter, response_queue):
        async for result in async_iter:
            current = self.current.get(result['id'], None)
            if not current:
                element_type = result['type']
                label = result['label']
                if element_type == 'vertex':
                    current = self.app.vertices.get(label, None)
                else:
                    current = self.app.edges.get(label, None)
                if not current:
                    # build generic element here
                    pass
                else:
                    current = current()
            element = current.__mapping__.mapper_func(result, current)
            response_queue.put_nowait(element)
        response_queue.put_nowait(None)

    # Creation API
    def add(self, *elements):
        for elem in elements:
            self._pending.append(elem)

    async def flush(self):
        while self._pending:
            elem = self._pending.popleft()
            await self.save(elem)

    async def remove_vertex(self, element):
        traversal = self.traversal_factory.remove_vertex(element)
        result = await self._simple_traversal(traversal, element)
        del self.current[element.id]
        return result

    async def remove_edge(self, element):
        traversal = self.traversal_factory.remove_edge(element)
        result = await self._simple_traversal(traversal, element)
        del self.current[element.id]
        return result

    async def save(self, element):
        if element.__type__ == 'vertex':
            result = await self.save_vertex(element)
        elif element.__type__ == 'edge':
            result = await self.save_edge(element)
        else:
            raise Exception("Unknown element type")
        return result

    async def save_vertex(self, element):
        result = await self._save_element(
            element, self._check_vertex,
            self.traversal_factory.add_vertex,
            self.traversal_factory.update_vertex)
        self.current[result.id] = result
        return result

    async def save_edge(self, element):
        if not (hasattr(element, 'source') and hasattr(element, 'target')):
            raise Exception("Edges require source/target vetices")
        result = await self._save_element(
            element, self._check_edge,
            self.traversal_factory.add_edge,
            self.traversal_factory.update_edge)
        self.current[result.id] = result
        return result

    async def get_vertex(self, element):
        return await self.traversal_factory.get_vertex_by_id(
            element).one_or_none()

    async def get_edge(self, element):
        return await self.traversal_factory.get_edge_by_id(
            element).one_or_none()

    # Transaction support
    def tx(self):
        raise NotImplementedError

    def _wrap_in_tx(self):
        raise NotImplementedError

    async def commit(self):
        await self.flush()
        if self.engine._features['transactions'] and self._use_session():
            await self.tx()
        raise NotImplementedError

    async def rollback(self):
        raise NotImplementedError

    # *metodos especiales privados for creation API
    async def _simple_traversal(self, traversal, element):
        stream = await self.conn.submit(
            repr(traversal), bindings=traversal.bindings)
        msg = await stream.fetch_data()
        if msg:
            msg = element.__mapping__.mapper_func(msg, element)
            return msg

    async def _save_element(self,
                            element,
                            check_func,
                            create_func,
                            update_func):
        if hasattr(element, 'id'):
            result = await check_func(element)
            if not result:
                traversal = create_func(element)
            else:
                traversal = update_func(element)
        else:
            traversal = create_func(element)
        return await self._simple_traversal(traversal, element)

    async def _check_vertex(self, element):
        """Used to check for existence, does not update session element"""
        traversal = self.g.V(element.id)
        stream = await self.conn.submit(repr(traversal))
        return await stream.fetch_data()

    async def _check_edge(self, element):
        """Used to check for existence, does not update session element"""
        traversal = self.g.E(element.id)
        stream = await self.conn.submit(repr(traversal))
        return await stream.fetch_data()
