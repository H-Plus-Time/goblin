"""Query API and helpers"""
import asyncio
import logging

from goblin import gremlin_python
from goblin import mapper


logger = logging.getLogger(__name__)


def parse_traversal(traversal):
    script = traversal.translator.traversal_script
    bindings = traversal.bindings
    return script, bindings


class QueryResponse:

    def __init__(self, response_queue):
        self._queue = response_queue
        self._done = False

    async def __aiter__(self):
        return self

    async def __anext__(self):
        if self._done:
            return
        msg = await self._queue.get()
        if msg:
            return msg
        else:
            self._done = True
            raise StopAsyncIteration


class Query:
    """Provides interface for user generated queries"""
    def __init__(self, session, translator):
        self._session = session
        self._traversal_source = gremlin_python.PythonGraphTraversalSource(
            translator)
        self._binding = 0

    @property
    def session(self):
        return self._session

    @property
    def g(self):
        return self.traversal_source

    @property
    def traversal_source(self):
        return self._traversal_source

    # Generative query methods...
    def filter(self, **kwargs):
        """Add a filter to the query"""
        raise NotImplementedError

    def traversal(self, element_class):
        pass

    # Methods that issue a traversal query to server
    async def _all(self, traversal, element_class):
        """Get all results generated by query"""
        async_iter = await self.session.execute_traversal(traversal)
        response_queue = asyncio.Queue(loop=self._loop)
        self._loop.create_task(
            self._receive(async_iter, response_queue, element_class))
        return QueryResponse(response_queue)

    async def _receive(self, async_iter, response_queue, element_class):
        async for msg in async_iter:
            results = msg.data
            for result in results:
                current = self.session.current.get(result['id'], None)
                if not current:
                    current = element_class()
                element = self._mapper(result, current, current.__mapping__)
                response_queue.put_nowait(element)
        response_queue.put_nowait(None)

    # Common CRUD methods that generate traversals
    def remove_vertex(self, element):
        return self.g.V(element.id).drop()

    def remove_edge(self, element):
        return self.g.E(element.id).drop()

    def get_vertex_by_id(self, element):
        return self.g.V(element.id)

    def get_edge_by_id(self, element):
        return self.g.E(element.id)

    def add_vertex(self, element):
        props = mapper.map_props_to_db(element, element.__mapping__)
        traversal = self.g.addV(element.__mapping__.label)
        return self._add_properties(traversal, props)

    def add_edge(self, element):
        props = mapper.map_props_to_db(element, element.__mapping__)
        traversal = self.g.V(element.source.id)
        traversal = traversal.addE(element.__mapping__._label)
        traversal = traversal.to(self.g.V(element.target.id))
        return self._add_properties(traversal, props)

    def update_vertex(self, element):
        props = mapper.map_props_to_db(element, element.__mapping__)
        traversal = self.g.V(element.id)
        return self._add_properties(traversal, props)

    def update_edge(self, element):
        props = mapper.map_props_to_db(element, element.__mapping__)
        traversal = self.g.E(element.id)
        return self._add_properties(traversal, props)

    def _add_properties(self, traversal, props):
        for k, v in props:
            if v:
                traversal = traversal.property(
                    ('k' + str(self._binding), k),
                    ('v' + str(self._binding), v))
                self._binding += 1
        self._binding = 0
        return traversal
