"""Query API and helpers"""
import asyncio
import logging

from goblin import gremlin_python
from goblin import mapper


logger = logging.getLogger(__name__)


def parse_traversal(traversal):
    script = traversal.translator.traversal_script
    bindings = traversal.bindings
    return script, bindings


class QueryResponse:

    def __init__(self, response_queue):
        self._queue = response_queue
        self._done = False

    async def __aiter__(self):
        return self

    async def __anext__(self):
        if self._done:
            return
        msg = await self._queue.get()
        if msg:
            return msg
        else:
            self._done = True
            raise StopAsyncIteration


class GoblinTraversal(gremlin_python.PythonGraphTraversal):

    def __init__(self, translator, query, element_class, mapper_func):
        super().__init__(translator, remote_connection=None)
        self._query = query
        self._element_class = element_class
        self._mapper_func = mapper_func

    async def all(self):
        result = await self._query._all(self)
        self._query = None
        return result

    @property
    def element_class(self):
        return self._element_class

    @property
    def mapper_func(self):
        return self._mapper_func


class Query:
    """Provides interface for user generated queries"""
    def __init__(self, session, translator, loop):
        self._session = session
        self._translator = translator
        self._traversal_source = gremlin_python.PythonGraphTraversalSource(
            self._translator)
        self._loop = loop
        self._binding = 0

    @property
    def session(self):
        return self._session

    @property
    def g(self):
        return self.traversal_source

    @property
    def traversal_source(self):
        return self._traversal_source

    # Generative query methods...
    def filter(self, **kwargs):
        """Add a filter to the query"""
        raise NotImplementedError

    def traversal(self, element_class):

        if element_class.__type__ == 'vertex':
            mapper_func = mapper.map_vertex_to_ogm
            traversal = GoblinTraversal(self._translator, self, element_class,
                                        mapper_func)
            traversal.translator.addSpawnStep(traversal, "V")
        if element_class.__type__ == 'edge':
            mapper_func = mapper.map_edge_to_ogm
            traversal = GoblinTraversal(self._translator, self, element_class,
                                        mapper_func)
            traversal.translator.addSpawnStep(traversal, "E")
        return traversal.hasLabel(element_class.__mapping__.label)

    # Methods that issue a traversal query to server
    async def _all(self, traversal):
        """Get all results generated by query"""
        async_iter = await self.session.execute_traversal(traversal)
        response_queue = asyncio.Queue(loop=self._loop)
        self._loop.create_task(
            self._receive(async_iter, response_queue, traversal.element_class,
                          traversal.mapper_func))
        return QueryResponse(response_queue)

    async def _receive(self, async_iter, response_queue, element_class,
                       mapper_func):
        async for msg in async_iter:
            # import ipdb; ipdb.set_trace()
            results = msg.data
            if results:
                for result in results:
                    current = self.session.current.get(result['id'], None)
                    if not current:
                        current = element_class()
                    element = mapper_func(result, current, current.__mapping__)
                    response_queue.put_nowait(element)
        response_queue.put_nowait(None)

    # Common CRUD methods that generate traversals
    def remove_vertex(self, element):
        return self.g.V(element.id).drop()

    def remove_edge(self, element):
        return self.g.E(element.id).drop()

    def get_vertex_by_id(self, element):
        return self.g.V(element.id)

    def get_edge_by_id(self, element):
        return self.g.E(element.id)

    def add_vertex(self, element):
        props = mapper.map_props_to_db(element, element.__mapping__)
        traversal = self.g.addV(element.__mapping__.label)
        return self._add_properties(traversal, props)

    def add_edge(self, element):
        props = mapper.map_props_to_db(element, element.__mapping__)
        traversal = self.g.V(element.source.id)
        traversal = traversal.addE(element.__mapping__._label)
        traversal = traversal.to(self.g.V(element.target.id))
        return self._add_properties(traversal, props)

    def update_vertex(self, element):
        props = mapper.map_props_to_db(element, element.__mapping__)
        traversal = self.g.V(element.id)
        return self._add_properties(traversal, props)

    def update_edge(self, element):
        props = mapper.map_props_to_db(element, element.__mapping__)
        traversal = self.g.E(element.id)
        return self._add_properties(traversal, props)

    def _add_properties(self, traversal, props):
        for k, v in props:
            if v:
                traversal = traversal.property(
                    ('k' + str(self._binding), k),
                    ('v' + str(self._binding), v))
                self._binding += 1
        self._binding = 0
        return traversal
